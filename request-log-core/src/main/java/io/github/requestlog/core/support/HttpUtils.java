package io.github.requestlog.core.support;

import org.springframework.util.CollectionUtils;
import org.springframework.util.StringUtils;

import java.util.*;


/**
 * Utility class for HTTP-related operations.
 */
public class HttpUtils {


    private static final Set<String> AUTO_GENERATED_HEADERS = new HashSet<>(Arrays.asList(
            "accept", "accept-charset", "accept-encoding", "accept-language", "accept-ranges",
            "access-control-allow-credentials", "access-control-allow-headers", "access-control-allow-methods", "access-control-allow-origin", "access-control-expose-headers",
            "access-control-max-age", "access-control-request-headers", "access-control-request-method", "age", "allow",
            "alt-svc", "authorization", "cache-control", "connection", "content-disposition",
            "content-encoding", "content-language", "content-length", "content-location", "content-md5",
            "content-range", "content-type", "cookie", "date", "etag",
            "expect", "expires", "forwarded", "from", "host",
            "if-match", "if-modified-since", "if-none-match", "if-range", "if-unmodified-since",
            "keep-alive", "last-modified", "location", "max-forwards", "origin",
            "pragma", "proxy-authenticate", "proxy-authorization", "range", "referer",
            "retry-after", "sec-fetch-dest", "sec-fetch-mode", "sec-fetch-site", "sec-fetch-user",
            "server", "set-cookie", "strict-transport-security", "trailer", "transfer-encoding",
            "upgrade", "user-agent", "vary", "via", "www-authenticate",
            "warning", "x-content-type-options", "x-frame-options", "x-xss-protection"
    ));


    /**
     * Check if the given HTTP header is automatically generated.
     *
     * @param headerName HTTP header name
     * @return true if the header is automatically generated; false otherwise
     */
    public static boolean autoGeneratedHeader(String headerName) {
        return StringUtils.hasText(headerName) && AUTO_GENERATED_HEADERS.contains(headerName.toLowerCase());
    }

    /**
     * Check if the specified HTTP header should be specified manually.
     *
     * @param headerName HTTP header name
     * @return true if the header should be specified manually; false otherwise
     */
    public static boolean shouldSpecifyManually(String headerName) {
        return StringUtils.hasText(headerName) && !autoGeneratedHeader(headerName);
    }


    /**
     * Find the 'Content-Type' value from the given HTTP headers map.
     */
    public static String findContentType(Map<String, List<String>> headerMap) {
        if (CollectionUtils.isEmpty(headerMap)) {
            return null;
        }
        for (String key : headerMap.keySet()) {
            if ("content-type".equalsIgnoreCase(key)) {
                List<String> values = headerMap.get(key);
                if (!CollectionUtils.isEmpty(values)) {
                    return CollectionUtils.firstElement(values);
                }
            }
        }
        return null;
    }


    /**
     * Checks if the HTTP status code indicates success (2xx range).
     */
    public static boolean isSuccess(Integer httpCode) {
        return httpCode != null && (httpCode >= 200 && httpCode < 300);
    }

}
